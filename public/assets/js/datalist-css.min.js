(() => {
    let listActive; document.body.addEventListener('focusin', listShow); function listShow(e) {
        const input = target(e); if (!input) return; if (input.list) { const dl = input.list; input.datalist = dl; input.removeAttribute('list'); dl.input = input; dl.setAttribute('tabindex', -1); input.addEventListener('input', listLimit); input.addEventListener('keydown', listControl); dl.addEventListener('keydown', listKey); dl.addEventListener('click', listSet) }
        const dl = input.datalist; if (dl && !dl.shown) { listHide(listActive); dl.shown = !0; listLimit(e); dl.style.width = input.offsetWidth + 'px'; dl.style.left = input.offsetLeft + 'px'; dl.style.display = 'block'; listActive = dl }
    }
    function listHide(dl) { if (dl && dl.shown) { dl.style.display = 'none'; dl.shown = !1 } }
    function listLimit(e) { const input = target(e); if (!input || !input.datalist) return; const v = input.value.trim().toLowerCase(); Array.from(input.datalist.getElementsByTagName('option')).forEach(opt => { opt.setAttribute('tabindex', 0); opt.style.display = !v || opt.value.toLowerCase().includes(v) ? 'block' : 'none' }) }
    function listControl(e) {
        const input = target(e); if (!input || !input.datalist) return; switch (e.keyCode) {
            case 40: { let opt = input.datalist.firstElementChild; if (!opt.offsetHeight) opt = visibleSibling(opt, 1); opt && opt.focus(); break }
            case 9: listHide(input.datalist); break; case 13: case 32: listSet(e); break
        }
    }
    const keymap = { 33: -12, 34: 12, 38: -1, 40: 1 }; function listKey(e) { const t = target(e); if (!t) return; const kc = e.keyCode, dir = keymap[kc], dl = t.parentElement; if (dir) { let opt = visibleSibling(t, dir); opt && opt.focus(); e.preventDefault() } else if (kc === 9 || kc === 13 || kc === 32) { listSet(e) } else if (kc === 8) { dl.input.focus() } else if (kc === 27) { listHide(dl) } }
    function visibleSibling(opt, dir) {
        let newOpt = opt; do {
            if (dir < 0) { newOpt = newOpt.previousElementSibling } else if (dir > 0) { newOpt = newOpt.nextElementSibling }
            if (newOpt && newOpt.offsetHeight) { opt = newOpt; dir -= Math.sign(dir) }
        } while (newOpt && dir); return opt
    }
    function listSet(e) {
        const
        t = target(e), dl = t && t.parentElement; if (!dl || !dl.input) return; dl.input.value = (t && t.value) || ''; listHide(dl)
    }
    function target(t) { return t && t.target }
})()
